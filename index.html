<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Janna Huang</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/avatar.jpeg)">
        </div>
    </section>
    <section class='menu'>
        <div>Janna Huang</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/06/commonly-used-es-6/">常用的 ES6 语法</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-06T06:07:18.000Z" itemprop="datePublished">
    2020-07-06
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了，其正式名称是 ES2015。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>通过 <strong>var</strong> 声明的变量或者非严格模式下(non-strict mode)创建的函数声明没有块级作用域。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>
<p>块中的 var x语句与块前面的var x语句作用域相同，因此输出 2。</p>
<p>而使用 <strong>let 和 const</strong> 声明的变量是有块级作用域的。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>
<p>以上用 const 同理，x = 2仅限在定义它的块中。</p>
<p>使用let声明的变量在块级作用域内能强制执行更新变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i);&#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]();                <span class="comment">// 10</span></span><br><span class="line">a[<span class="number">1</span>]();                <span class="comment">// 10</span></span><br><span class="line">a[<span class="number">6</span>]();                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i);&#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]();                <span class="comment">// 0</span></span><br><span class="line">a[<span class="number">1</span>]();                <span class="comment">// 1</span></span><br><span class="line">a[<span class="number">6</span>]();                <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="块级变量-let"><a href="#块级变量-let" class="headerlink" title="块级变量 let"></a>块级变量 let</h2><p>let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>let 声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位于函数或代码顶部的var声明会给全局对象新增属性, 而let不会。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// "global"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p>在同一个函数或块作用域中重复声明同一个变量会引起 SyntaxError。<br>如： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo;</span><br><span class="line">  <span class="keyword">let</span> foo; <span class="comment">// SyntaxError thrown.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂存死区"><a href="#暂存死区" class="headerlink" title="暂存死区"></a>暂存死区</h3><p>通过 var 声明的初始化值为 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。而在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="块级常量-const"><a href="#块级常量-const" class="headerlink" title="块级常量 const"></a>块级常量 const</h2><p>常量是块级作用域，常量的值不能通过重新赋值来改变，并且不能重新声明。一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>
<p>创建一个常量，其作用域可以是全局或本地声明的块。<br>const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定this。</p>
<h2 id="更短的函数"><a href="#更短的函数" class="headerlink" title="更短的函数"></a>更短的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = [</span><br><span class="line">  <span class="string">'Hydrogen'</span>,</span><br><span class="line">  <span class="string">'Helium'</span>,</span><br><span class="line">  <span class="string">'Lithium'</span>,</span><br><span class="line">  <span class="string">'Beryllium'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">elements.map(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> element.length; </span><br><span class="line">&#125;); <span class="comment">// 返回数组：[8, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的普通函数可以改写成如下的箭头函数</span></span><br><span class="line">elements.map(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> element.length;</span><br><span class="line">&#125;); <span class="comment">// [8, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当箭头函数只有一个参数时，可以省略参数的圆括号</span></span><br><span class="line">elements.map(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> element.length;</span><br><span class="line">&#125;); <span class="comment">// [8, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号</span></span><br><span class="line">elements.map(<span class="function"><span class="params">element</span> =&gt;</span> element.length); <span class="comment">// [8, 6, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构</span></span><br><span class="line"><span class="comment">// 需要注意的是字符串 `"length"` 是我们想要获得的属性的名称，而 `lengthFooBArX` 则只是个变量名，</span></span><br><span class="line"><span class="comment">// 可以替换成任意合法的变量名</span></span><br><span class="line">elements.map(<span class="function">(<span class="params">&#123; <span class="string">"length"</span>: lengthFooBArX &#125;</span>) =&gt;</span> lengthFooBArX); <span class="comment">// [8, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h2 id="词法-this"><a href="#词法-this" class="headerlink" title="词法 this"></a>词法 this</h2><p>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承 this。因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 值相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>由于箭头函数没有自己的 this 指针，通过 call()、apply() 或 bind()方法调用一个函数时，不能指定作用域，只能传参数，因此第一个参数会被忽略。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;        </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure>

<h1 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>以前一般是在函数体测试参数若为 undefined 则设置默认值，现在有默认参数后直接设置即可。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ?  b : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>, <span class="number">2</span>); <span class="comment">// 10</span></span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>, <span class="number">2</span>); <span class="comment">// 10</span></span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。如果函数的最后一个命名参数以…为前缀，则它将成为一个由剩余参数组成的真数组，其中从 0（包括）到 theArgs.length（排除）的元素由传递给函数的实际参数提供。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fun1();  <span class="comment">// 弹出 "0", 因为theArgs没有元素</span></span><br><span class="line">fun1(<span class="number">5</span>); <span class="comment">// 弹出 "1", 因为theArgs只有一个元素</span></span><br><span class="line">fun1(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 "3", 因为theArgs有三个元素</span></span><br></pre></td></tr></table></figure>

<p>剩余参数只包含那些没有对应形参的实参。<br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>剩余参数和 arguments 对象的区别：</p>
<ul>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li>
<li>arguments对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop。</li>
<li>arguments对象还有一些附加的属性（如 callee 属性）。</li>
</ul>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortRestArgs</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = theArgs.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortRestArgs(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 弹出 1,3,5,7</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = <span class="built_in">arguments</span>.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs; <span class="comment">// 不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortArguments(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 抛出TypeError异常:arguments.sort is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h2><p>展开语法(Spread syntax)，可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。</p>
<p>语法：</p>
<ul>
<li>函数调用：myFunction(…iterableObj);</li>
<li>字面量数组构造或字符串：[…iterableObj, ‘4’, …’hello’, 6];</li>
<li>构造字面量对象时,进行克隆或者属性拷贝：let objClone = { …obj };</li>
</ul>
<p><strong>在函数调用时使用展开语法：</strong><br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction(...args);</span><br></pre></td></tr></table></figure>

<p><strong>构造字面量数组时使用展开语法：</strong><br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parts = [<span class="string">'shoulders'</span>, <span class="string">'knees'</span>]; </span><br><span class="line"><span class="keyword">var</span> lyrics = [<span class="string">'head'</span>, ...parts, <span class="string">'and'</span>, <span class="string">'toes'</span>]; </span><br><span class="line"><span class="comment">// ["head", "shoulders", "knees", "and", "toes"]</span></span><br></pre></td></tr></table></figure>
<p>数组拷贝(copy)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// like arr.slice()</span></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 此时变成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure>
<p>连接多个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1 = [...arr2, ...arr1]; <span class="comment">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p><strong>构造字面量对象时使用展开语法:</strong><br>浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并，可以使用更简短的展开语法。而不必再使用 Object.assign() 方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="对象属性加强"><a href="#对象属性加强" class="headerlink" title="对象属性加强"></a>对象属性加强</h1><h2 id="属性定义支持短语法-obj-x-y"><a href="#属性定义支持短语法-obj-x-y" class="headerlink" title="属性定义支持短语法 obj = { x, y }"></a>属性定义支持短语法 obj = { x, y }</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"foo"</span>, </span><br><span class="line">    b = <span class="number">42</span>,</span><br><span class="line">    c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: a,</span><br><span class="line">  b: b,</span><br><span class="line">  c: c</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ES6 写法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;a, b, c&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="属性名可计算"><a href="#属性名可计算" class="headerlink" title="属性名可计算"></a>属性名可计算</h2><p>对象初始化语法开始支持计算属性名。其允许在[]中放入表达式，计算结果可以当做属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [<span class="string">"foo"</span> + ++i]: i,</span><br><span class="line">  [<span class="string">"foo"</span> + ++i]: i,</span><br><span class="line">  [<span class="string">"foo"</span> + ++i]: i</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.foo1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.foo2); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.foo3); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> param = <span class="string">'size'</span>;</span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">  [param]: <span class="number">12</span>,</span><br><span class="line">  [<span class="string">"mobile"</span> + param.charAt(<span class="number">0</span>).toUpperCase() + param.slice(<span class="number">1</span>)]: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(config); <span class="comment">// &#123; size: 12, mobileSize: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, rest;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [30, 40, 50]</span></span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stage 4（已完成）提案中的特性</span></span><br><span class="line">(&#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

<p>在一个解构表达式中可以交换两个变量的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">p</span>: foo, <span class="attr">q</span>: bar&#125; = o;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 42 </span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>从作为函数实参的对象中提取数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userId</span>(<span class="params">&#123;id&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whois</span>(<span class="params">&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(displayName + <span class="string">" is "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123; </span><br><span class="line">  id: <span class="number">42</span>, </span><br><span class="line">  displayName: <span class="string">"jdoe"</span>,</span><br><span class="line">  fullName: &#123; </span><br><span class="line">      firstName: <span class="string">"John"</span>,</span><br><span class="line">      lastName: <span class="string">"Doe"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"userId: "</span> + userId(user)); <span class="comment">// "userId: 42"</span></span><br><span class="line">whois(user); <span class="comment">// "jdoe is John"</span></span><br></pre></td></tr></table></figure>

<p><em>以上笔记参考 MDN</em></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/05/what-is-the-prototype-chain/">什么是 JS 原型链？</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-05T13:24:31.000Z" itemprop="datePublished">
    2020-07-05
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>原型链的基本概念是每个实例对象（object）都有一个私有属性（称之为__ proto__，即[[ Prototype]]）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（__ proto__），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。如此层层递进，构成了实例与原型的链条。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">// 继承了 SuperType</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以上代码可见，SubType 的原型被替换成 SuperType 的实例，继承了 SuperType 的属性和方法，在此基础上，还可以利用 SubType.prototype 给 SubType 添加属性和方法。</p>
<p>当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到，则继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。</p>
<p>比如上例在调用 instance.getSuperValu()时经历 3 个搜索步骤：</p>
<ol>
<li>搜索实例 instance，无果，向上搜索</li>
<li>搜索 SubType.prototype，无果，向上搜索</li>
<li>搜索 SuperType.prototype，找到了，停止搜索</li>
</ol>
<p>所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针指向 Object.prototype，因此所有自定义类型都会继承 Object.prototype 的默认方法。</p>
<h2 id="如何确定原型和实例的关系"><a href="#如何确定原型和实例的关系" class="headerlink" title="如何确定原型和实例的关系"></a>如何确定原型和实例的关系</h2><p>我们可以通过两种方式确定原型和实例之间的关系：</p>
<ol>
<li>instanceof 操作符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>isPrototypeOf() 方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="定义方法注意事项"><a href="#定义方法注意事项" class="headerlink" title="定义方法注意事项"></a>定义方法注意事项</h2><ol>
<li>给原型添加方法的代码一定要放在替换原型的语句之后</li>
<li>不能使用对象字面量创建原型方法，这样会重写原型链</li>
</ol>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType() <span class="comment">//继承了 SuperType，替换原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量添加新方法，会导致上一行代码无效 </span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">  getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">  &#125;,</span><br><span class="line">  someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()) <span class="comment">//报错：instance.getSuperValue is not a function!</span></span><br><span class="line"><span class="comment">// SubType 和 SuperType 之间已没有关系</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h2><ol>
<li>包含引用类型值的原型属性会被所有实例共享</li>
<li>不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/04/apply-call-bind/">apply()，call()和 bind()的作用和区别</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-04T04:29:14.000Z" itemprop="datePublished">
    2020-07-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>每个函数都有三个方法：apply()，call()和 bind()。用途都是在特定的作用域中调用函数。</p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h1><p>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。第二个参数可以是 Array 的实例，或者是 arguments 对象。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]) <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h1 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h1><p>call()方法和 apply()方法的作用相同，区别仅在于<strong>接收参数的方式不同</strong>。对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数，即传递给函数的参数必须逐个列举出来。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><p>bind()方法会创建一个函数的实例，称为绑定函数。当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  color: <span class="string">"blue"</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor.bind(o)() <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h1 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h1><ul>
<li>三者都能够扩充函数赖以运行的作用域，改变 this 的指向，好处是对象不需要与方法有任何耦合关系。</li>
<li>三者的第一个参数都是 this 要指向的对象。</li>
<li>apply() 和 call()都是立即执行，而 bind() 返回的是函数，需要再执行一次。</li>
</ul>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">"blue"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor() <span class="comment">// red</span></span><br><span class="line">sayColor.apply(<span class="keyword">this</span>) <span class="comment">// red</span></span><br><span class="line">sayColor.apply(<span class="built_in">window</span>) <span class="comment">// red</span></span><br><span class="line">sayColor.call() <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>) <span class="comment">// red</span></span><br><span class="line">sayColor.call(o) <span class="comment">// blue</span></span><br><span class="line">sayColor.bind(o)() <span class="comment">// blue</span></span><br><span class="line">sayColor.bind()() <span class="comment">// red</span></span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/03/create-object/">JS 创建对象的 7 种模式</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-03T03:42:12.000Z" itemprop="datePublished">
    2020-07-03
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Object/">Object</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>JS 创建对象有 7 种模式，分别是工厂模式、构造函数模式、原型模式、组合使用构造函数模式和原型模式、动态原型模式、寄生构造函数模式和稳妥构造函数模式，前 4 种较为常用，而<strong>组合使用构造函数模式和原型模式</strong>是推荐使用的一种。</p>
<h1 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h1><p>工厂模式解决了创建多个相似对象问题，但没有解决对象识别的问题，即无法知道一个对象的类型。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Jen"</span>, <span class="number">29</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Lisa"</span>, <span class="number">28</span>, <span class="string">"Dancer"</span>)</span><br></pre></td></tr></table></figure>
<p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象，不限调用次数，每次调用都返回一个包含三个属性一个方法的对象。</p>
<h1 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2.构造函数模式"></a>2.构造函数模式</h1><p>ES 中的构造函数可以用来创建特定类型的对象，可以创建自定义的构造函数，自定义对象类型的属性和方法。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Jen"</span>, <span class="number">29</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Lisa"</span>, <span class="number">28</span>, <span class="string">"Dancer"</span>)</span><br></pre></td></tr></table></figure>
<p>与工厂模式<strong>不同</strong>，Person()函数：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给 this 对象</li>
<li>没有 return 语句</li>
</ul>
<blockquote>
<p>构造函数名始终应该以大写字母开头，而非构造函数则应该以小写字母开头。主要用于区别其他函数，因为<strong>构造函数本身也是函数，只是可以用于创建对象</strong>。</p>
</blockquote>
<p>必须使用 new 操作符创建新实例。用这种方式调用构造函数会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）</li>
<li>执行构造函数中的代码（为新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>上例创建的对象 person1 和 person2 都有一个 constructor(构造函数)属性，指向 Person。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对象的 constructor 属性最初用来识别对象类型，但是用 instanceof 操作符来检测对象类型会更可靠。上例创建的对象既是 Person 的实例，也是 Object 的实例（万物皆对象，所有对象均继承自 Object）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。</p>
<h2 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h2><p>构造函数与其他函数的唯一区别在于调用方式不同。通过 new 操作符调用，它就可以作为构造函数；否则即是普通函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Jen"</span>, <span class="number">29</span>, <span class="string">"Engineer"</span>) <span class="comment">// 添加到 window</span></span><br><span class="line"><span class="built_in">window</span>.sayName() <span class="comment">// "Jen"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">Person.call(o, <span class="string">"Lisa"</span>, <span class="number">28</span>, <span class="string">"Dancer"</span>)</span><br><span class="line">o.sayName() <span class="comment">// "Lisa"</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h2><p>构造函数的主要问题是每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数不相等，但却完成同样但任务。可以将函数定义转移到构造函数外部，对象就能共享在全局作用域中定义但同一个函数。</p>
<p>可是在全局作用域定义但函数却之被某个对象调用，如果对象需要定义很多方法，就要定义很多个全局函数，这样但自定义引用类型就没有封装性了。</p>
<h1 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h1><p>创建的每个函数都有一个 prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。</p>
<p>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Jen"</span></span><br><span class="line">Person.prototype.age = <span class="number">29</span></span><br><span class="line">Person.prototype.job = <span class="string">"Engineer"</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName() <span class="comment">// "Jen"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName() <span class="comment">// "Jen"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原型模式的缺点：</p>
<ol>
<li>省略了为构造函数传递初始化参数的环境，以致所有实例在默认情况下都将取得相同的属性值。</li>
<li>对于包含引用类型值的属性，比如引用的数组，单个实例修改数组，也会对其他实例引用的值产生影响，因为指向的是同一个数组。</li>
</ol>
<h1 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4.组合使用构造函数模式和原型模式"></a>4.组合使用构造函数模式和原型模式</h1><p>创建自定义类型的最常见方式就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参 数。<br>这种模式是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"J"</span>, <span class="string">"L"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, </span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Jen"</span>, <span class="number">29</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Lisa"</span>, <span class="number">28</span>, <span class="string">"Dancer"</span>)</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"V"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends) <span class="comment">//"J,L,V" </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends) <span class="comment">//"J,L"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h1 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5.动态原型模式"></a>5.动态原型模式</h1><p>动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中只有 sayName()方法不存在的情况下，才会将它添加到原型中。只会在初次调用构造函数时才会执行。这里对原型所做的修改，能够立即反映在所有实例中。</p>
<h1 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6.寄生构造函数模式"></a>6.寄生构造函数模式</h1><p>这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。</p>
<p>寄生构造函数模式返回的对象与构造函数或者与构造函数的原型属性之间没有关系。所以不能依赖 instanceof 操作符来确定对象类型。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Jen"</span>, <span class="number">29</span>, <span class="string">"Engineer"</span>); friend.sayName(); <span class="comment">// "Jen"</span></span><br></pre></td></tr></table></figure>
<h1 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7.稳妥构造函数模式"></a>7.稳妥构造函数模式</h1><p>稳妥对象指的是没有公共属性，而且其方法也不引用 this 的对象。<br>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：</p>
<ol>
<li>新创建对象的实例方法不引用 this</li>
<li>不使用 new 操作符调用构造函数</li>
</ol>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建要返回的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以定义私有变量和函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回对象</span></span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述创建的对象，除了调用 sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境下使用。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/02/property-type-of-object/">JS 对象属性类型</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-02T12:57:04.000Z" itemprop="datePublished">
    2020-07-02
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Object/">Object</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>ECMA-262 第 5 版在定义只有内部才用的特性时，描述了属性的各种特征。定义这些特性是为了实现 JS 引擎所用，在 JS 中不能直接访问。为了区分特性是内部值，规范把特性用[[ ]]括起来了，例如[[ Enumerable]]。</p>
<p>ECMAScript 中包含两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong>。</p>
<h1 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h1><p>数据属性包含一个数据值的位置，可以读取和写入值。<br>数据属性有 4 个描述其行为的特性：</p>
<ul>
<li>[[ Configurable]] <ul>
<li>可配置的：表示能否通过 delete 删除属性从而<strong>重新定义属性</strong>，能否<strong>修改属性的特性</strong>，或者能否<strong>把属性修改为访问器属性</strong>。直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
</ul>
</li>
<li>[[ Enumerable]] <ul>
<li>可数的，可枚举的：表示能否通过 for-in 循环返回属性值。直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
</ul>
</li>
<li>[[ Writable]]<ul>
<li>可写的：表示能否修改属性的值。直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
</ul>
</li>
<li>[[ Value]]<ul>
<li>值：包含这个属性的数据值。读取属性值时，从这个位置读取；写入属性值时，把新值保存于此。这个特性的默认值为 undefined。</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"janna"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个名为 name 的属，为它指定值“janna”，即[[ Value]]特性被设置为“janna”。</p>
<p>要修改属性默认特性，须用 ES5 的 Object.defineProperty()方法。该方法接受三个参数：configurable、enumerable、writable 和 value。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 即不可修改属性的值</span></span><br><span class="line">  value: <span class="string">"janna"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"haha"</span> <span class="comment">// 赋值失效</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "janna"</span></span><br></pre></td></tr></table></figure>

<p>再如，把 configurable 设置为 false，表示不能从对象中删除属性。而且，<strong>一旦把属性定义为不可配置，就不能再把它变为可配置</strong>。而此时再调用 Object.defineProperty()方法修改<strong>除 writable 之外</strong>的特性，都会导致错误。</p>
<p><strong>在调用 Object.defineProperty()方法时，如果不指定。则configurable、enumerable 和 writable 特性的默认值都是 false</strong>。</p>
<h1 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h1><p>访问器属性不包含数据值，它包含一对函数 getter 和 setter。在读取访问器属性时，会调用 getter 函数，负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，负责决定如何处理数据。</p>
<p>访问器属性有 4 个特性：</p>
<ul>
<li>[[ Configurable]] <ul>
<li>可配置的：表示能否通过 delete 删除属性从而<strong>重新定义属性</strong>，能否<strong>修改属性的特性</strong>，或者能否<strong>把属性修改为数据属性</strong>。直接在对象上定义的属性，这个特性默认值为 true。</li>
</ul>
</li>
<li>[[ Enumerable]] <ul>
<li>可数的，可枚举的：表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，这个特性默认值为 true。</li>
</ul>
</li>
<li>[[ Get]]<ul>
<li>读取：读取属性时调用的函数。默认值为 undefined。</li>
</ul>
</li>
<li>[[ Set]]<ul>
<li>写入：写入属性时调用的函数。默认值为 undefined。</li>
</ul>
</li>
</ul>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty()来定义。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2020</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2020</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2020</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2021</span> <span class="comment">// 写入时调用 setter，修改了 _year 和 edition</span></span><br><span class="line"><span class="built_in">console</span>.log(book.edition) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性不能写入，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。只指定 setter 函数的属性也不能读，否则在非严格模式下返回 undefined，严格模式下会抛出错误。</p>
<p>在不支持 Object.defineProperty()方法的浏览器中不能修改 [[ Configurable]]和[[ Enumerable]]。</p>
<hr>
<p>发现在遇到不懂的问题时，红宝书作为教材挺好用的，讲得很详细。年初说要手抄一遍红宝书的，半途而废了，希望今年能抄完。：）</p>
<p>有位小哥哥问我平时有没写技术博客，好惭愧啊竟然没有，立马建了博客写起来，哪怕是记录学习笔记也是好的。</p>
<p><strong>不积硅步，无以千里。</strong></p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2020 - Janna Huang </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm" target="_blank" rel="noopener">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>
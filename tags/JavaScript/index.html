<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Janna Huang</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/avatar.jpeg)">
        </div>
    </section>
    <section class='menu'>
        <div>Janna Huang</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ JavaScript }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/28/how-to-inherit/">如何实现继承？</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-28T14:02:54.000Z" itemprop="datePublished">
    2020-07-28
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>子类实例的原型链上可以获取父类的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>把父类的原型放到子类实例的原型链上，实例可以通过 __ proto__ 原型链查找机制调取其属性和方法。</li>
<li>子类可以重写父类上的方法，会导致父类其他实例受到影响</li>
<li>子类可以获取父类中私有或公有的属性和方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="number">200</span>)</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">Child.prototype.getY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="number">100</span>)</span><br><span class="line">child1.y</span><br><span class="line">child1.getY()</span><br><span class="line">child1.getX()</span><br></pre></td></tr></table></figure>

<h1 id="call-apply-继承"><a href="#call-apply-继承" class="headerlink" title="call/apply 继承"></a>call/apply 继承</h1><p>子类方法中把父类当作普通函数执行，让父类中的 this 指向子类的实例，相当于给子类的实例设置了私有的属性和方法。<br>特点：</p>
<ol>
<li>把父类当作普通函数执行，和原型上的属性和方法无关，所以只能继承父类私有的属性和方法</li>
<li>父类私有的属性和方法变成子类私有的属性和方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, <span class="number">200</span>) <span class="comment">// this 指向 B 的实例，child1.x = 200</span></span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.getY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="number">100</span>)</span><br><span class="line">child1.y</span><br><span class="line">child1.x</span><br></pre></td></tr></table></figure>

<h1 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h1><p>CALL 继承与类似于原型继承结合。</p>
<p>特点：<br>父类私有和公有的属性和方法分别是子类实例的私有和公有的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, <span class="number">200</span>) <span class="comment">// this 指向 B 的实例，child1.x = 200</span></span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype) </span><br><span class="line"><span class="comment">// Object.create(OBJ) 用于创建一个空对象，让空对象 __prototype__ 指向 OBJ</span></span><br><span class="line"><span class="comment">// 如果不用 Object.create 方法，可改用以下代码</span></span><br><span class="line"><span class="comment">// Object.create = function (OBJ) &#123;</span></span><br><span class="line"><span class="comment">//   function Fn() &#123;&#125;</span></span><br><span class="line"><span class="comment">//   Fn.prototype = OBJ</span></span><br><span class="line"><span class="comment">//   return new Fn()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">Child.prototype.getY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="number">100</span>)</span><br><span class="line">child1.y</span><br><span class="line">child1.x</span><br></pre></td></tr></table></figure>

<h1 id="ES6-class-继承"><a href="#ES6-class-继承" class="headerlink" title="ES6 class 继承"></a>ES6 class 继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">  getX() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; <span class="comment">// 相当于 Child.prototype.__proto__ = Parent.prototype</span></span><br><span class="line">  <span class="keyword">constructor</span>(y) &#123; </span><br><span class="line">    <span class="comment">// 不写 constructor 浏览器会默认创建 constructor(...args)&#123; super(...args) &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(<span class="number">200</span>) </span><br><span class="line">    <span class="comment">// 不写 super 会报错。</span></span><br><span class="line">    <span class="comment">// super(200) 相当于 Parent.call(this, 200)，把父类当做普通方法执行，给方法传递参数，让方法中当 this 指向子类当实例</span></span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  getY() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure>

<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="不用-class-继承"><a href="#不用-class-继承" class="headerlink" title="不用 class 继承"></a>不用 class 继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color, name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>, color)</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">temp.prototype = Animal.prototype</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> temp()</span><br><span class="line"></span><br><span class="line">Dog.prototype.constructor = Dog</span><br><span class="line">Dog.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wow'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'yellow'</span>, <span class="string">'doggy'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="用-class-继承"><a href="#用-class-继承" class="headerlink" title="用 class 继承"></a>用 class 继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(color)&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  move()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(color, name)&#123;</span><br><span class="line">    <span class="keyword">super</span>(color)</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  say()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wow'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/27/MVC-and-MVVM/">MVC 和 MVVM 模式</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-27T13:19:19.000Z" itemprop="datePublished">
    2020-07-27
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>软件可分为三个部分：</p>
<ol>
<li>视图 View：用户界面</li>
<li>控制器 Controller：业务逻辑</li>
<li>模型 Model：数据保存</li>
</ol>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="MVC"></p>
<p>各部分之间的通信是单向的：</p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新数据发送给 View，反馈给用户</li>
</ol>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>将 Controller 改为 ViewModel。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="MVVM"></p>
<p>各部分之间的通信是双向的，View 与 Model 不发生联系，通过 ViewModel 传递。逻辑部署在 ViewModel。</p>
<p>采用双向绑定，View 的变动自动反映在 ViewModel，ViewModel 的变动也反映在 View。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/21/what-is-the-event-loop/">事件循环 Event Loop 是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-21T13:36:53.000Z" itemprop="datePublished">
    2020-07-21
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>JavaScript 是一门单线程的非阻塞的脚本语言。<br>单线程意思是 JavaScript 在执行的时候只有一个主线程处理所有任务。<br>非阻塞意思是当需要执行一项异步任务，其结果无法立刻返回的时候，主线程会挂起该任务，等异步任务返回结果时再执行相应的回调。</p>
<h1 id="浏览器环境下-JS-引擎"><a href="#浏览器环境下-JS-引擎" class="headerlink" title="浏览器环境下 JS 引擎"></a>浏览器环境下 JS 引擎</h1><p>由于 JavaScript 是单线程，同时只能执行一个方法，当多个方法被依次调用时，这些方法会按照执行顺序排队放入执行栈。<br>同步代码执行时，当执行一个方法，JavaScript 会在执行栈中添加该方法的执行环境以执行代码。当执行完毕并返回结果后，JavaScript 会退出当前环境并把该执行环境销毁。直至执行栈中的代码全部执行完毕。<br>而遇到异步事件后，会将该事件挂起，继续执行执行栈中的任务。当异步事件返回结果后，JavaScript 会将该事件加入到事件队列。等执行栈中的任务执行完毕，主线程会查找事件队列中是否还有任务，再将对应事件的回调放入执行栈中执行。<br>这个过程会一直循环，所以称之为事件循环。</p>
<hr>
<p>而任务之间执行顺序也有优先级之分，分为微任务 Microtask 和宏任务 MacroTask。<br>当执行栈任务执行完，会优先处理微任务队列中当事件，再处理宏任务事件。</p>
<h2 id="微任务-MicroTask"><a href="#微任务-MicroTask" class="headerlink" title="微任务 MicroTask"></a>微任务 MicroTask</h2><ol>
<li>Process.nextTick（Node 独有）</li>
<li>Promise</li>
<li>MutationObserver</li>
</ol>
<h2 id="宏任务-MacroTask"><a href="#宏任务-MacroTask" class="headerlink" title="宏任务 MacroTask"></a>宏任务 MacroTask</h2><ol>
<li>script 的全部代码</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate（浏览器暂时不支持）</li>
<li>I/O</li>
<li>UI Rendering</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)  <span class="comment">// 主线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1() <span class="comment">// 执行 async2</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>) <span class="comment">// 宏任务最后执行</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="comment">// new Promise 立即执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<h1 id="Node-的事件循环"><a href="#Node-的事件循环" class="headerlink" title="Node 的事件循环"></a>Node 的事件循环</h1><p>Node 的事件循环存在于 libuv 引擎中，表现的状态跟浏览器中的大致相同。</p>
<p>共有以下 6 个阶段：</p>
<ol>
<li>timers: <ul>
<li>执行 setTimeout 和 setInterval 中到期的 callback。</li>
</ul>
</li>
<li>I/O callbacks: <ul>
<li>上一轮循环中少数的 callback 会放在这一阶段执行。</li>
<li>此阶段执行某些系统操作（例如TCP错误类型）的回调。 </li>
</ul>
</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: <ul>
<li>最重要的阶段，执行pending callback，在适当的情况下阻塞在这里。</li>
<li>两个主要功能：<ul>
<li>执行 I/O 回调。</li>
<li>处理轮询队列中的事件。</li>
</ul>
</li>
</ul>
</li>
<li>check: <ul>
<li>执行 setImmediate 的 callback。</li>
</ul>
</li>
<li>close callbacks: <ul>
<li>执行 close 事件的 callback。</li>
</ul>
</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/20/what-is-the-debounce-and-throttle/">节流 throttle 和防抖 debounce 是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-20T13:58:16.000Z" itemprop="datePublished">
    2020-07-20
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>节流和防抖是控制事件触发频率的方法，可以节约性能，防止事件频繁触发造成页面卡顿，影响用户体验。</p>
<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>多次触发情况下，让函数在一段时间内只执行一次。<br>可以理解为车站按时间表发车，比如 10 分钟发一趟车。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canUse = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canUse) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      canUse = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        canUse = <span class="literal">true</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func 是要执行的函数，delay 是延迟的时间。throttle 内部设置一个变量 canUse 以控制函数是否可以执行。当 canUse 为 true，函数执行，并且将 canUse 置为 false，再用定时器控制 delay 时间后将 canUse 置为 true。这样就算多次触发事件，函数 func 只会在指定时间内执行一次。</p>
<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>多次触发情况下，让函数在最后一次触发后间隔一段时间再执行。<br>可以理解为汽车到站后，乘客陆续上车，当最后一名乘客上车坐好后，再开车。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">      <span class="built_in">window</span>.clearTimeout(timeoutId)</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      timeoutId = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func 是要执行的函数，delay 是延迟的时间。debounce 内部设置一个变量 timeoutId，用于存放每次新的定时器。当连续触发事件时，如果 timeoutId 不为空，即已有定时器，就清除该定时器，重新设置定时器。这样即便多次触发事件，函数 func 只会在最后一次触发后的 delay 时间后执行。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/16/what-is-the-storage/">Storage 接口是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-16T09:37:22.000Z" itemprop="datePublished">
    2020-07-16
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>脚本用 Storage 接口在浏览器保存数据。window.sessionStorage 和 window.localStorage 部署了该接口。</p>
<p>两者的区别是保存时间不同：</p>
<ol>
<li>sessionStorage 保存的数据用于浏览器的一次会话（session），通常在关闭窗口即会话结束时，清空数据。</li>
<li>localStorage 保存的数据长期存在，下次访问时还可以读取之前保存的数据，除非手动清除数据。</li>
</ol>
<p><strong>数据以文本格式保存，以键值对形式保存。</strong></p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>Storage.length：返回保存的数据项个数。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol>
<li><p>Storage.setItem() ：用于存入数据。</p>
<ul>
<li>接受两个参数，第一个是键名，第二个是键值。如果键名存在，则更新键值。</li>
<li>如果参数不是字符串，则自动转换为字符串，再存入浏览器。</li>
<li>如果储存空间满了，用此方法会报错。</li>
<li>可以直接赋值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三种写法等价</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.foo = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">window</span>.localStorage[<span class="string">'foo'</span>] = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">'foo'</span>, <span class="string">'123'</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Storage.getItem()：用于读取数据。</p>
<ul>
<li>接受一个参数，键名。</li>
<li>如果键名不存在，返回 null。</li>
<li>参数不是字符串，则自动转为字符串。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.getItem(<span class="string">'key'</span>)</span><br><span class="line"><span class="built_in">window</span>.localStorage.getItem(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Storage.removeItem()：用于清除某个键名对应的键值。</p>
<ul>
<li>接受一个参数，键名。</li>
<li>如果键名不存在，则不进行任何操作。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">'key'</span>)</span><br><span class="line"><span class="built_in">window</span>.localStorage.removeItem(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Storage.clear()：用于清除所有保存的数据。</p>
<ul>
<li>该方法的返回值是 undefined。</li>
</ul>
</li>
<li><p>Storage.key()接受一个整数（从 0 开始）作为参数，返回该位置对应的键值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"><span class="built_in">window</span>.sessionStorage.key(<span class="number">0</span>) <span class="comment">// "key"</span></span><br></pre></td></tr></table></figure>




</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/15/what-is-the-cookie/">Cookie 是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-15T03:18:23.000Z" itemprop="datePublished">
    2020-07-15
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>这个 Cookie 不是曲奇，而是<strong>服务器保存在浏览器的一小段文本信息，用于存储用户信息</strong>，一般大小不超过 4KB。当浏览器向服务器发送请求时，会附上 Cookie 信息，服务器可通过 Cookie 获取用户信息。</p>
<p>由于 Cookie 容量很小，不宜存放过多信息，应该只存放每次请求都需要让服务器知道的信息。</p>
<p>Cookie 以名/值对形式存储，有以下几种元数据：</p>
<ol>
<li>Cookie 的名称 cookie-name</li>
<li>Cookie 的值 cookie-value</li>
<li>过期时间 expires</li>
<li>所属域名（默认为当前域名） domain</li>
<li>生效的路径（默认为当前网址） path<ul>
<li>如果 Cookie 生效路径不是跟路径/，而假设为/xxx，那这个 Cookie 在/xxx 及其子路径访问时才有效。</li>
</ul>
</li>
</ol>
<p>浏览器访问某个路径前，会先找出对该域名和路径都有效，而且未过期的 Cookie，再发送给服务器。</p>
<blockquote>
<p>不同浏览器对 Cookie 数量和大小的限制不同。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。</p>
</blockquote>
<h1 id="Cookie-与-HTTP-协议"><a href="#Cookie-与-HTTP-协议" class="headerlink" title="Cookie 与 HTTP 协议"></a>Cookie 与 HTTP 协议</h1><p>Cookie 由 HTTP 协议生成，也主要供 HTTP 协议使用。</p>
<h2 id="HTTP-响应：生成-Cookie"><a href="#HTTP-响应：生成-Cookie" class="headerlink" title="HTTP 响应：生成 Cookie"></a>HTTP 响应：生成 Cookie</h2><p>如果服务器希望在浏览器保存 Cookie，可以在 HTTP 响应头里放置一个 Set-Cookie 字段。可以放置多个 Set-Cookie 字段，在浏览器生成多个 Cookie。除了 Cookie 名/值，Set-Cookie 还可以附加 Cookie 的属性，可以包含多个属性，没有次序要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Max-Age=&lt;non-zero-digit&gt;; Expires=&lt;date&gt;; Path=&lt;path-value&gt;; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-请求：发送-Cookie"><a href="#HTTP-请求：发送-Cookie" class="headerlink" title="HTTP 请求：发送 Cookie"></a>HTTP 请求：发送 Cookie</h2><p>当浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。使用 HTTP 头信息的 Cookie 字段，可以包含多个 Cookie，使用分号;分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<p>服务器收到浏览器发送的 Cookie，无法知道：</p>
<ol>
<li>Cookie 的各种属性</li>
<li>是哪个域名设置的 Cookie</li>
</ol>
<h1 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h1><h2 id="1-Expires，Max-Age"><a href="#1-Expires，Max-Age" class="headerlink" title="1. Expires，Max-Age"></a>1. Expires，Max-Age</h2><p><strong>Expires 属性指定一个具体的到期时间</strong>，时间到了浏览器就不保留这个 Cookie。属性值是 UTC 格式，可以使用 Date.prototype.toUTCString()进行格式转换。浏览器根据本地时间决定是否过期，所以不能保证 Cookie 会在服务器指定时间过期。</p>
<p><strong>Max-Age 属性指定从现在开始 Cookie 存在的秒数</strong>，比如 60 * 60 * 24 是一天后过期。</p>
<p>如果同时设置 Expires 或 Max-Age 属性，<strong>Max-Age 优先生效</strong>。如果不设置 Expires 或 Max-Age 属性，或者设为 null，表示 Cookie 只在当前会话有效，关闭浏览器该 Cookie 即被删除。</p>
<h2 id="2-Domain，Path"><a href="#2-Domain，Path" class="headerlink" title="2. Domain，Path"></a>2. Domain，Path</h2><p>Domain 属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。如果指定了domain属性，那么子域名也会附带这个 Cookie。</p>
<p>如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。</p>
<p>Path 属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。在域名一致的前提下，浏览器发现 Path 子路径，就会在头信息里带上 Cookie。</p>
<h2 id="3-Secure，HttpOnly"><a href="#3-Secure，HttpOnly" class="headerlink" title="3. Secure，HttpOnly"></a>3. Secure，HttpOnly</h2><p>Secure 属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。</p>
<p>HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<h2 id="4-SameSite"><a href="#4-SameSite" class="headerlink" title="4. SameSite"></a>4. SameSite</h2><p>SameSite 属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值：</p>
<ol>
<li>Strict<ul>
<li>最为严格，完全禁止第三方 Cookie，跨站点时任何情况下都不会发送 Cookie。</li>
</ul>
</li>
<li>Lax<ul>
<li>大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li>
</ul>
</li>
<li>None<ul>
<li>Chrome 计划将 Lax 变为默认设置。这时，网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: widget_session=abc123; SameSite=None; Secure</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>用户浏览器支持 SameSite 属性的情况下，设置 Strict 或 Lax 以后，基本就杜绝了 CSRF 攻击。</p>
<h1 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h1><p>可以使用 document.cookie 属性来增删改查 Cookie。在 Cookie 没有 HTTPOnly 属性时，读取会返回当前网页的所有 Cookie，用分号隔开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=Jack; expires=Tue, 18 Aug 2020 12:00:00 GMT; path=/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'fontSize=14; '</span></span><br><span class="line">  + <span class="string">'expires='</span> + someDate.toGMTString() + <span class="string">'; '</span></span><br><span class="line">  + <span class="string">'path=/subdirectory; '</span></span><br><span class="line">  + <span class="string">'domain=*.example.com'</span>;</span><br></pre></td></tr></table></figure>

<p>写入 Cookie 注意点：</p>
<ol>
<li>Cookie 的值必须写成 key=value 的形式，<strong>等号两边不能有空格</strong>。</li>
<li>必须对分号、逗号和空格进行转义，可以用encodeURIComponent。</li>
<li>一次只能写入一个 Cookie，而且<strong>不是覆盖</strong>，是添加。</li>
<li>可以同时写入 Cookie 的属性。</li>
<li>path 属性必须为绝对路径，默认为当前路径。</li>
<li>domain 属性值必须是当前发送 Cookie 的域名的一部分。</li>
<li>max-age属性的值为秒数。</li>
<li>expires属性的值为 UTC 格式，可以使用 Date.prototype.toUTCString()进行日期格式转换。</li>
<li>Cookie 的属性一旦设置完成，就<strong>不能读取这些属性的值</strong>。</li>
<li>删除一个现存 Cookie 的<strong>唯一方法</strong>，是将 expires 属性设为一个过去的日期。</li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/10/what-is-the-this/">this 关键字</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-10T13:09:07.000Z" itemprop="datePublished">
    2020-07-10
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <p>this 代表属性或方法当前所在的对象，this 的指向是可变的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.describe = A.describe;</span><br><span class="line">B.describe() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>
<p>上例中，A.describe 函数赋值给了 B，这时调用 B.describe()，this 指向方法当前所在的对象 B，所以 this.name 是’李四’。</p>
<p><strong>当函数被赋值给另一个变量，this 指向改变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="keyword">var</span> f = A.describe;</span><br><span class="line">f() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>
<p>上例中将 A.describe 赋值给外部变量 f，this 指向外部，即 f 运行时所在的对象。</p>
<h1 id="this-存在的原因"><a href="#this-存在的原因" class="headerlink" title="this 存在的原因"></a>this 存在的原因</h1><p>当把一个对象赋值给变量时，JavaScript 引擎会先在内存中生成一个对象，然后把该对象当内存地址赋值给变量。当读取该变量时，JavaScript 引擎先从变量拿到内存地址，再从内存地址中读取原始当对象返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实是用以下 属性描述对象 形式保存：</span></span><br><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span>  <span class="comment">// 值存在属性描述对象当 value 属性</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当属性的值是函数时，JavaScript 会将函数单独保存在内存中，再将函数的地址赋值给属性的 value 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行，也因此所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。而设计 this 的目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独执行，this 指向全局环境</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 环境执行，this 指向 obj</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="this-使用场合"><a href="#this-使用场合" class="headerlink" title="this 使用场合"></a>this 使用场合</h1><ol>
<li>全局环境下运行，this 指向的就是顶层 window</li>
<li>构造函数中的 this 指向的是实例对象</li>
<li>对象的方法</li>
</ol>
<ul>
<li>如果对象的方法里面包含 this，this 的指向就是方法运行时所在的对象。当该方法赋值给另一个对象，就会改变 this 的指向。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而以下这几种用法，都会改变this的指向</span></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.foo = obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, obj.foo)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三种情况等同于：</span></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
上例中 obj.foo 相当于一个值，在调用时运行环境是全局环境。</li>
</ul>
<p>如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  p: <span class="string">'Hello'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>要输出预期值则改写成如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/09/clone-and-clone-deep/">如何实现浅拷贝和深拷贝</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-09T04:26:25.000Z" itemprop="datePublished">
    2020-07-09
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>JavaScript 基本的数据类型有 7 种：</p>
<ol>
<li>undefined：表示未定义或不存在，此处没有任何值。</li>
<li>null：表示空值，此处的值为空。</li>
<li>boolean 布尔值：表示真伪，true 和 false。</li>
<li>number 数值：整数和小数。</li>
<li>string 字符串：文本。</li>
<li>object 对象：各种值组成的集合。可以分成三个子类型：狭义的对象 object、数组 array、函数 function。</li>
<li>symbol：ES6 新增的一种基本数据类型。一个 symbol 值能作为对象属性的标识符，每个从 Symbol()返回的 symbol 值都是唯一的。</li>
</ol>
<p>确定一个值的类型有 3 种方法：</p>
<ol>
<li>typeof 运算符</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString 方法</li>
</ol>
<p>数值、字符串、布尔值分别返回number、string、boolean，属于基本类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></span><br></pre></td></tr></table></figure>
<p>对象返回 object，属于引用类型，即指向某一个地址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>当引用一个值的时候，如果是基本类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">11</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 11</span></span><br><span class="line">b = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>将 a 赋值给 b 之后，修改 b 不会对 a 产生影响。</p>
<p>而当引用的值为引用类型时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'janna'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123; name: 'janna' &#125;</span></span><br><span class="line">b.name = lisa</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123; name: 'lisa' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123; name: 'lisa' &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于 a 和 b 是引用了同一个值的地址，修改 b 即修改同一个地址的值，会影响到 a。这时候就需要用到拷贝，而拷贝又分为浅拷贝和深拷贝。</p>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝只能拷贝第一层的值，如果里面的值还有引用类型，就要用到深拷贝。</p>
<ol>
<li><p>for 循环，将对象里的值逐一赋值给新对象，再返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    newObj[key] = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.assign(target, source)，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ol>
<li>引入第三方工具，如 lodash cdn</li>
<li>JSON 序列化和反序列化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，JSON 方法<strong>不适用于包含 function 的对象</strong>，无法序列化 function。</p>
</blockquote>
</li>
<li>手动实现深拷贝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// 分为数组和对象处理</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj[key])) &#123;</span><br><span class="line">        <span class="comment">// 用 map 返回新数组，将数组中的元素递归</span></span><br><span class="line">        newObj[key] = obj[key].map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.deepClone(item)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归返回新对象</span></span><br><span class="line">        newObj[key] = <span class="keyword">this</span>.deepClone(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 函数用 bind 指定作用域返回</span></span><br><span class="line">      newObj[key] = obj[key].bind(newObj)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 基本类型直接返回</span></span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/09/await-and-async/">async 和 await 是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-09T02:49:19.000Z" itemprop="datePublished">
    2020-07-09
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="async-和-await-是什么"><a href="#async-和-await-是什么" class="headerlink" title="async 和 await 是什么"></a>async 和 await 是什么</h1><p>async 函数是 Generator 函数的语法糖，Generator 函数是 ES6 提供的一种异步编程解决方案。async 函数与 Promise、Generator 函数实现同个功能相比，async 函数的实现最简洁，代码量最少。</p>
<p>async 函数与 Generator 函数相比的优点在于：</p>
<ol>
<li>内置执行器<ul>
<li>async 函数的执行，与普通函数一致。</li>
</ul>
</li>
<li>更好的语义<ul>
<li>async 表示函数里有异步操作，await 表示紧跟其后的表达式需要等待结果。</li>
</ul>
</li>
<li>更广的适用性<ul>
<li>async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li>
</ul>
</li>
<li>返回值是 Promise<ul>
<li>async 函数的返回值是 Promise 对象，可以用 then 方法指定下一步操作。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>async 函数可以看作是由多个异步操作包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</strong></p>
</blockquote>
<h1 id="async-和-await-怎么用"><a href="#async-和-await-怎么用" class="headerlink" title="async 和 await 怎么用"></a>async 和 await 怎么用</h1><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行时，遇到 await 就会先等 await 后面的异步操作完成，再接着执行函数体后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async 改写写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上例中当调用函数时，会立即返回一个 Promise 对象。由于async函数返回的是 Promise 对象，可以作为 await 命令的参数。因此上例 timeout 可以改写成 async 方法。</p>
<p>async 函数还有多种使用形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>async 函数内部return语句返回的值，会成为 then 方法回调函数的参数。async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>

<p>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，才会执行 then 方法指定的回调函数。</p>
<h2 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h2><p>一般来说，await 命令会返回其后 Promise 对象当结果，如果不是 Promise 对象，则直接返回其值。<br>如果 await 命令后面是一个 thenable 对象（即定义了 then 方法的对象），那么 await 会将其等同于 Promise 对象。</p>
<p>使用 await 命令可以让程序停顿指定当时间，以下是 sleep 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, interval);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">one2FiveInAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">one2FiveInAsync();</span><br></pre></td></tr></table></figure>

<p>await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>); <span class="comment">// 不用 return 也能接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>如果 await 命令后面的 Promise 对象变为 reject 状态，则整个 async 函数中断执行。如果想让 async 函数不中断执行，有两种方法：</p>
<ol>
<li>可以将 await 命令放在一个 try…catch…结构里。</li>
<li>await 命令后面的 Promise 对象加一个 catch 方法，以处理错误。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用 try...catch...</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 在 await 的 Promise 后加一个 .catch 方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol>
<li>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</li>
<li>多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发，缩短程序的执行时间。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure></li>
<li>await 命令只能在 async 函数中使用，如果用在普通函数就会报错。</li>
<li>async 函数可以保留运行堆栈。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> b();</span><br><span class="line">  c();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上例中 b()运行的时候，a()是暂停执行，上下文环境都保存着。一旦 b()或 c()报错，错误堆栈将包括 a()。</li>
</ol>
<p><em>笔记参考 阮一峰 async 函数</em></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2020/07/08/what-is-the-cross-origin/">跨域是什么</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2020-07-08T07:56:40.000Z" itemprop="datePublished">
    2020-07-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="跨域是什么？"><a href="#跨域是什么？" class="headerlink" title="跨域是什么？"></a>跨域是什么？</h1><p>只要协议、域名、端口有任何一个不同，就是不同的域，它们之间的请求就是跨域请求。而浏览器的同源策略出于安全考虑，只允许同域下的请求。</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><h2 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1. CORS"></a>1. CORS</h2><p>CORS 跨域资源共享（Cross-origin resource sharing）允许浏览器向跨域的服务器发出 XMLHttpRequest 请求。</p>
<p>CORS 需要浏览器和服务器同时支持，即分别在浏览器请求和服务器中添加相关字段。</p>
<ol>
<li>浏览器请求<br>浏览器发现 ajax 请求跨域时，会自动添加一些附加的头信息。<ul>
<li>需要注意的是，请求中需要设置 withCredentials 为 true，以发送 Cookie.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>服务器<br>在响应头中添加相关字段。</li>
</ol>
<ul>
<li>Access-Control-Allow-Origin，必选，设置为请求时 Origin 字段的值，或者设置为 * 表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials，可选，设置为 true 表示允许浏览器把 Cookie 包含在请求中一起发给服务器。</li>
</ul>
<h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a>2. JSONP</h2><p>JSONP(JSON with Padding) 是 json 的一种”使用模式”，可以跨域读取数据。</p>
<ol>
<li>在网页添加一个&lt; script&gt;元素，向服务器请求一个脚本。带上一个 callback 参数，用于告诉服务器浏览器的回调函数是 func。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://xxx.com?callback=func"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>服务器接收到请求后，将回调函数名和 JSON 数据拼接成一个字符串，以字符串形式返回，如 res.send(func+”{console.log(‘Hello’)}”)，即返回 func({console.log(‘Hello’)})。</li>
<li>浏览器会将服务器返回的字符串当作代码解释，在浏览器中定义的 func()函数执行，可以拿到服务器返回的 JSON 数据。</li>
</ol>
<blockquote>
<p><strong>CORS 与 JSONP 区别：</strong></p>
<ol>
<li>CORS 支持所有类型的 HTTP 请求，JSONP 只支持 GET 请求</li>
<li>JSONP 支持老式浏览器</li>
</ol>
</blockquote>
<h2 id="3-服务器代理跨域"><a href="#3-服务器代理跨域" class="headerlink" title="3. 服务器代理跨域"></a>3. 服务器代理跨域</h2><p>Nginx 和 Node.js 中间件服务器代理跨域，由于服务器不存在跨域问题，可以由服务器请求所要域的资源再返回。由后端处理，就不展开细说。</p>

      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/tags/JavaScript/page/2/">2</a><a class="extend next" rel="next" href="/tags/JavaScript/page/2/">next »</a>
    </nav>
  </section>



            <footer>
    <div>© 2020 - Janna Huang </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm" target="_blank" rel="noopener">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>